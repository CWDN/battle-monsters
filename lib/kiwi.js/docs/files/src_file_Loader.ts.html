<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/file/Loader.ts - Kiwi.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Kiwi.js"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.2.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Kiwi.Animations.Animation.html">Kiwi.Animations.Animation</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Sequence.html">Kiwi.Animations.Sequence</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tween.html">Kiwi.Animations.Tween</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Back.html">Kiwi.Animations.Tweens.Easing.Back</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Bounce.html">Kiwi.Animations.Tweens.Easing.Bounce</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Circular.html">Kiwi.Animations.Tweens.Easing.Circular</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Cubic.html">Kiwi.Animations.Tweens.Easing.Cubic</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Elastic.html">Kiwi.Animations.Tweens.Easing.Elastic</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Exponential.html">Kiwi.Animations.Tweens.Easing.Exponential</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Linear.html">Kiwi.Animations.Tweens.Easing.Linear</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Quadratic.html">Kiwi.Animations.Tweens.Easing.Quadratic</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Quartic.html">Kiwi.Animations.Tweens.Easing.Quartic</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Quintic.html">Kiwi.Animations.Tweens.Easing.Quintic</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Sinusoidal.html">Kiwi.Animations.Tweens.Easing.Sinusoidal</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.TweenManager.html">Kiwi.Animations.Tweens.TweenManager</a></li>
            
                <li><a href="../classes/Kiwi.Camera.html">Kiwi.Camera</a></li>
            
                <li><a href="../classes/Kiwi.CameraManager.html">Kiwi.CameraManager</a></li>
            
                <li><a href="../classes/Kiwi.Component.html">Kiwi.Component</a></li>
            
                <li><a href="../classes/Kiwi.ComponentManager.html">Kiwi.ComponentManager</a></li>
            
                <li><a href="../classes/Kiwi.Components.AnimationManager.html">Kiwi.Components.AnimationManager</a></li>
            
                <li><a href="../classes/Kiwi.Components.ArcadePhysics.html">Kiwi.Components.ArcadePhysics</a></li>
            
                <li><a href="../classes/Kiwi.Components.Box.html">Kiwi.Components.Box</a></li>
            
                <li><a href="../classes/Kiwi.Components.Input.html">Kiwi.Components.Input</a></li>
            
                <li><a href="../classes/Kiwi.Components.Sound.html">Kiwi.Components.Sound</a></li>
            
                <li><a href="../classes/Kiwi.Entity.html">Kiwi.Entity</a></li>
            
                <li><a href="../classes/Kiwi.Files.AudioFile.html">Kiwi.Files.AudioFile</a></li>
            
                <li><a href="../classes/Kiwi.Files.DataFile.html">Kiwi.Files.DataFile</a></li>
            
                <li><a href="../classes/Kiwi.Files.DataLibrary.html">Kiwi.Files.DataLibrary</a></li>
            
                <li><a href="../classes/Kiwi.Files.File.html">Kiwi.Files.File</a></li>
            
                <li><a href="../classes/Kiwi.Files.FileStore.html">Kiwi.Files.FileStore</a></li>
            
                <li><a href="../classes/Kiwi.Files.Loader.html">Kiwi.Files.Loader</a></li>
            
                <li><a href="../classes/Kiwi.Files.TextureFile.html">Kiwi.Files.TextureFile</a></li>
            
                <li><a href="../classes/Kiwi.Game.html">Kiwi.Game</a></li>
            
                <li><a href="../classes/Kiwi.GameManager.html">Kiwi.GameManager</a></li>
            
                <li><a href="../classes/Kiwi.GameObjects.Sprite.html">Kiwi.GameObjects.Sprite</a></li>
            
                <li><a href="../classes/Kiwi.GameObjects.StaticImage.html">Kiwi.GameObjects.StaticImage</a></li>
            
                <li><a href="../classes/Kiwi.GameObjects.TextField.html">Kiwi.GameObjects.TextField</a></li>
            
                <li><a href="../classes/Kiwi.GameObjects.Tilemap.TileMap.html">Kiwi.GameObjects.Tilemap.TileMap</a></li>
            
                <li><a href="../classes/Kiwi.GameObjects.Tilemap.TileMapLayer.html">Kiwi.GameObjects.Tilemap.TileMapLayer</a></li>
            
                <li><a href="../classes/Kiwi.GameObjects.Tilemap.TileType.html">Kiwi.GameObjects.Tilemap.TileType</a></li>
            
                <li><a href="../classes/Kiwi.Geom.AABB.html">Kiwi.Geom.AABB</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Circle.html">Kiwi.Geom.Circle</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Intersect.html">Kiwi.Geom.Intersect</a></li>
            
                <li><a href="../classes/Kiwi.Geom.IntersectResult.html">Kiwi.Geom.IntersectResult</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Line.html">Kiwi.Geom.Line</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Matrix.html">Kiwi.Geom.Matrix</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Point.html">Kiwi.Geom.Point</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Ray.html">Kiwi.Geom.Ray</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Rectangle.html">Kiwi.Geom.Rectangle</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Transform.html">Kiwi.Geom.Transform</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Vector2.html">Kiwi.Geom.Vector2</a></li>
            
                <li><a href="../classes/Kiwi.Group.html">Kiwi.Group</a></li>
            
                <li><a href="../classes/Kiwi.HUD.HUDComponents.Counter.html">Kiwi.HUD.HUDComponents.Counter</a></li>
            
                <li><a href="../classes/Kiwi.HUD.HUDComponents.Time.html">Kiwi.HUD.HUDComponents.Time</a></li>
            
                <li><a href="../classes/Kiwi.HUD.HUDComponents.WidgetInput.html">Kiwi.HUD.HUDComponents.WidgetInput</a></li>
            
                <li><a href="../classes/Kiwi.HUD.HUDDisplay.html">Kiwi.HUD.HUDDisplay</a></li>
            
                <li><a href="../classes/Kiwi.HUD.HUDManager.html">Kiwi.HUD.HUDManager</a></li>
            
                <li><a href="../classes/Kiwi.HUD.HUDWidget.html">Kiwi.HUD.HUDWidget</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.Bar.html">Kiwi.HUD.Widget.Bar</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.BasicScore.html">Kiwi.HUD.Widget.BasicScore</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.Button.html">Kiwi.HUD.Widget.Button</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.Icon.html">Kiwi.HUD.Widget.Icon</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.IconBar.html">Kiwi.HUD.Widget.IconBar</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.Menu.html">Kiwi.HUD.Widget.Menu</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.MenuItem.html">Kiwi.HUD.Widget.MenuItem</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.TextField.html">Kiwi.HUD.Widget.TextField</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.Time.html">Kiwi.HUD.Widget.Time</a></li>
            
                <li><a href="../classes/Kiwi.IChild.html">Kiwi.IChild</a></li>
            
                <li><a href="../classes/Kiwi.Input.Finger.html">Kiwi.Input.Finger</a></li>
            
                <li><a href="../classes/Kiwi.Input.InputManager.html">Kiwi.Input.InputManager</a></li>
            
                <li><a href="../classes/Kiwi.Input.Key.html">Kiwi.Input.Key</a></li>
            
                <li><a href="../classes/Kiwi.Input.Keyboard.html">Kiwi.Input.Keyboard</a></li>
            
                <li><a href="../classes/Kiwi.Input.Keycodes.html">Kiwi.Input.Keycodes</a></li>
            
                <li><a href="../classes/Kiwi.Input.Mouse.html">Kiwi.Input.Mouse</a></li>
            
                <li><a href="../classes/Kiwi.Input.MouseCursor.html">Kiwi.Input.MouseCursor</a></li>
            
                <li><a href="../classes/Kiwi.Input.Pointer.html">Kiwi.Input.Pointer</a></li>
            
                <li><a href="../classes/Kiwi.Input.Touch.html">Kiwi.Input.Touch</a></li>
            
                <li><a href="../classes/Kiwi.PluginManager.html">Kiwi.PluginManager</a></li>
            
                <li><a href="../classes/Kiwi.Renderers.CanvasRenderer.html">Kiwi.Renderers.CanvasRenderer</a></li>
            
                <li><a href="../classes/Kiwi.Renderers.GLArrayBuffer.html">Kiwi.Renderers.GLArrayBuffer</a></li>
            
                <li><a href="../classes/Kiwi.Renderers.GLBlendMode.html">Kiwi.Renderers.GLBlendMode</a></li>
            
                <li><a href="../classes/Kiwi.Renderers.GLElementArrayBuffer.html">Kiwi.Renderers.GLElementArrayBuffer</a></li>
            
                <li><a href="../classes/Kiwi.Renderers.GLRenderManager.html">Kiwi.Renderers.GLRenderManager</a></li>
            
                <li><a href="../classes/Kiwi.Renderers.GLTextureManager.html">Kiwi.Renderers.GLTextureManager</a></li>
            
                <li><a href="../classes/Kiwi.Renderers.GLTextureWrapper.html">Kiwi.Renderers.GLTextureWrapper</a></li>
            
                <li><a href="../classes/Kiwi.Renderers.Renderer.html">Kiwi.Renderers.Renderer</a></li>
            
                <li><a href="../classes/Kiwi.Renderers.TextureAtlasRenderer.html">Kiwi.Renderers.TextureAtlasRenderer</a></li>
            
                <li><a href="../classes/Kiwi.Shaders.ShaderManager.html">Kiwi.Shaders.ShaderManager</a></li>
            
                <li><a href="../classes/Kiwi.Shaders.ShaderPair.html">Kiwi.Shaders.ShaderPair</a></li>
            
                <li><a href="../classes/Kiwi.Shaders.TextureAtlasShader.html">Kiwi.Shaders.TextureAtlasShader</a></li>
            
                <li><a href="../classes/Kiwi.Signal.html">Kiwi.Signal</a></li>
            
                <li><a href="../classes/Kiwi.SignalBinding.html">Kiwi.SignalBinding</a></li>
            
                <li><a href="../classes/Kiwi.Sound.Audio.html">Kiwi.Sound.Audio</a></li>
            
                <li><a href="../classes/Kiwi.Sound.AudioLibrary.html">Kiwi.Sound.AudioLibrary</a></li>
            
                <li><a href="../classes/Kiwi.Sound.AudioManager.html">Kiwi.Sound.AudioManager</a></li>
            
                <li><a href="../classes/Kiwi.Stage.html">Kiwi.Stage</a></li>
            
                <li><a href="../classes/Kiwi.State.html">Kiwi.State</a></li>
            
                <li><a href="../classes/Kiwi.StateConfig.html">Kiwi.StateConfig</a></li>
            
                <li><a href="../classes/Kiwi.StateManager.html">Kiwi.StateManager</a></li>
            
                <li><a href="../classes/Kiwi.System.Bootstrap.html">Kiwi.System.Bootstrap</a></li>
            
                <li><a href="../classes/Kiwi.System.Device.html">Kiwi.System.Device</a></li>
            
                <li><a href="../classes/Kiwi.Textures.SingleImage.html">Kiwi.Textures.SingleImage</a></li>
            
                <li><a href="../classes/Kiwi.Textures.SpriteSheet.html">Kiwi.Textures.SpriteSheet</a></li>
            
                <li><a href="../classes/Kiwi.Textures.TextureAtlas.html">Kiwi.Textures.TextureAtlas</a></li>
            
                <li><a href="../classes/Kiwi.Textures.TextureLibrary.html">Kiwi.Textures.TextureLibrary</a></li>
            
                <li><a href="../classes/Kiwi.Time.Clock.html">Kiwi.Time.Clock</a></li>
            
                <li><a href="../classes/Kiwi.Time.ClockManager.html">Kiwi.Time.ClockManager</a></li>
            
                <li><a href="../classes/Kiwi.Time.MasterClock.html">Kiwi.Time.MasterClock</a></li>
            
                <li><a href="../classes/Kiwi.Time.Timer.html">Kiwi.Time.Timer</a></li>
            
                <li><a href="../classes/Kiwi.Time.TimerEvent.html">Kiwi.Time.TimerEvent</a></li>
            
                <li><a href="../classes/Kiwi.Utils.Canvas.html">Kiwi.Utils.Canvas</a></li>
            
                <li><a href="../classes/Kiwi.Utils.Color.html">Kiwi.Utils.Color</a></li>
            
                <li><a href="../classes/Kiwi.Utils.Common.html">Kiwi.Utils.Common</a></li>
            
                <li><a href="../classes/Kiwi.Utils.GameMath.html">Kiwi.Utils.GameMath</a></li>
            
                <li><a href="../classes/Kiwi.Utils.Log.html">Kiwi.Utils.Log</a></li>
            
                <li><a href="../classes/Kiwi.Utils.RandomDataGenerator.html">Kiwi.Utils.RandomDataGenerator</a></li>
            
                <li><a href="../classes/Kiwi.Utils.RequestAnimationFrame.html">Kiwi.Utils.RequestAnimationFrame</a></li>
            
                <li><a href="../classes/Kiwi.Utils.Version.html">Kiwi.Utils.Version</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/Animations.html">Animations</a></li>
            
                <li><a href="../modules/Components.html">Components</a></li>
            
                <li><a href="../modules/Easing.html">Easing</a></li>
            
                <li><a href="../modules/Files.html">Files</a></li>
            
                <li><a href="../modules/GameObjects.html">GameObjects</a></li>
            
                <li><a href="../modules/Geom.html">Geom</a></li>
            
                <li><a href="../modules/HUD.html">HUD</a></li>
            
                <li><a href="../modules/HUDComponents.html">HUDComponents</a></li>
            
                <li><a href="../modules/Input.html">Input</a></li>
            
                <li><a href="../modules/Kiwi.html">Kiwi</a></li>
            
                <li><a href="../modules/Renderers.html">Renderers</a></li>
            
                <li><a href="../modules/Shaders.html">Shaders</a></li>
            
                <li><a href="../modules/Sound.html">Sound</a></li>
            
                <li><a href="../modules/System.html">System</a></li>
            
                <li><a href="../modules/Textures.html">Textures</a></li>
            
                <li><a href="../modules/Tilemap.html">Tilemap</a></li>
            
                <li><a href="../modules/Time.html">Time</a></li>
            
                <li><a href="../modules/Tweens.html">Tweens</a></li>
            
                <li><a href="../modules/Utils.html">Utils</a></li>
            
                <li><a href="../modules/Utils..html">Utils.</a></li>
            
                <li><a href="../modules/Widget.html">Widget</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/file/Loader.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
* 
* @module Kiwi
* @submodule Files 
* 
*/

module Kiwi.Files {

	/**
	* Used for the loading of files and game assets. This usually happens when a State is at the &#x27;loading&#x27; stage (executing the &#x27;preload&#x27; method).
	* 
	* @class Loader
	* @namespace Kiwi.Files
	* @constructor
	* @param game {Kiwi.Game} The game that this loader belongs to.
	* @return {Kiwi.Files.Loader} This Object
	*
	*/
	export class Loader {
 
		constructor(game: Kiwi.Game) {

			this.game = game;

		}

		/**
		* The type of object this is.
		* @method objType
		* @return {String} &quot;Loader&quot;
		* @public
		*/
		public objType() {
			return &quot;Loader&quot;;
		}

		/**
		* The game this loader is attached to.
		* @property game 
		* @type Kiwi.Game
		* @public
		*/
		public game: Kiwi.Game;

		/**
		* A list of files that can be loaded in parallel to one another.
		* This list of files are currently being loaded. 
		* 
		* @property _loadingParallel
		* @type Array
		* @since 1.2.0
		* @private 
		*/
		private _loadingParallel: Kiwi.Files.File[];

		/**
		* List of files that cannot load in parallel to one another
		* and so need to wait for previous files to load first. 
		* Generally files loaded via XHR.
		* 
		* @property _loadingQueue
		* @type Array
		* @since 1.2.0
		* @private 
		*/
		private _loadingQueue: Kiwi.Files.File[];

		/**
		* List of files that are to be loaded. 
		* These files will be placed in the &#x27;_loadingQueue&#x27; or &#x27;_loadingParallel&#x27; 
		* lists when the queue is told to &#x27;start&#x27; loading.
		* 
		* @property _loadingList
		* @type Array
		* @since 1.2.0
		* @private 
		*/
		private _loadingList: Kiwi.Files.File[];

		/**
		* A Signal which dispatches callbacks when all files in the &#x27;loadingList&#x27; have been loaded.
		* When adding callbacks make sure to &#x27;remove&#x27; them (or to use the &#x27;addOnce&#x27; method) 
		* otherwise will fire when other sections use the loader.
		* 
		* @method onQueueComplete
		* @type Kiwi.Signal
		* @since 1.2.0
		* @public
		*/
		public onQueueComplete: Kiwi.Signal;

		/**
		* A Signal which dispatches callbacks each time a file in the &#x27;loadingList&#x27; have been loaded.
		* Callbacks dispatched are passed the following arguments in order.
		* 1. percent - The percentage of files loaded. A number from 0 - 100
		* 2. bytesLoaded - The number of bytes loaded 
		* 3. file - The latest file that was loaded. First call will be null.
		* 
		* When adding callbacks make sure to &#x27;remove&#x27; them (or to use the &#x27;addOnce&#x27; method) 
		* otherwise will fire when other sections use the loader.
		* 
		* @method onQueueProgress
		* @type Kiwi.Signal
		* @since 1.2.0
		* @public
		*/
		public onQueueProgress: Kiwi.Signal;


		/**
		* A flag indicating if the files inside the file queue are loading or not.
		* 
		* @property _fileQueueLoading
		* @type Boolean
		* @default false
		* @since 1.2.0
		* @private
		*/
		private _queueLoading: boolean = false;

		/**
		* READ ONLY: A flag indicating if the files inside the file queue are loading or not.
		* 
		* @property fileQueueLoading
		* @type Boolean
		* @default false
		* @readOnly
		* @since 1.2.0
		* @public
		*/
		public get queueLoading(): boolean {
			return this._queueLoading;
		}


		/**
		* When &#x27;calculateBytes&#x27; is true the percentLoaded will be the &#x60;bytesLoaded / bytesTotal&#x60;. 
		* Otherwise it is based on the &#x60;filesLoaded / numberOfFilesToLoad&#x60;. 
		*
		* @property percentLoaded
		* @type Number
		* @since 1.2.0
		* @readOnly
		* @public
		*/
		public percentLoaded: number = 0;


		/**
		* When enabled, files which can be loaded in parallel (those which are loaded via tags) 
		* will be loaded at the same time. 
		* 
		* The default behaviour is to have the files loading in a queued fashion instead of one after another.
		* 
		* @property enableParallelLoading
		* @type Boolean
		* @default false
		* @since 1.2.0
		* @public
		*/
		public enableParallelLoading: boolean = false; 


		/**
		* The boot method is executed when the DOM has successfully loaded and we can now start the game.
		* @method boot
		* @public
		*/
		public boot() {

			this._loadingList = [];

			this._loadingParallel = [];

			this._loadingQueue = [];

			this.onQueueComplete = new Kiwi.Signal();

			this.onQueueProgress = new Kiwi.Signal();

		}

		/**
		* Starts loading all the files which are in the file queue. 
		*
		* To accurately use the bytesLoaded or bytesTotal properties you will need to set the &#x27;calculateBytes&#x27; boolean to true.
		* This may increase load times, as each file in the queue will firstly make XHR HEAD requests for information.
		*
		* When &#x27;calculateBytes&#x27; is true the percentLoaded will be the &#x60;bytesLoaded / bytesTotal&#x60;. 
		* Otherwise it is based on the &#x60;filesLoaded / numberOfFilesToLoad&#x60;. 
		*
		* @method start
		* @param [calculateBytes] {Boolean} Setter for the &#x27;calculateBytes&#x27; property.
		* @since 1.2.0
		* @public
		*/ 
		public start(calculateBytes: boolean = null) {

			if (calculateBytes !== null) {
				this._calculateBytes = calculateBytes;
			}

			if (this._queueLoading) {
				Kiwi.Log.warn(&#x27;Kiwi.Files.Loader: Files in the queue are already being loaded&#x27;);
				return;
			}

			//Reset the number of bytes laoded
			this._bytesLoaded = 0;
			this._bytesTotal = 0;
			this.percentLoaded = 0;

			if (this._calculateBytes) {
				this.calculateQueuedSize(this._startLoading, this);
			} else {
				this._startLoading();
			}

		}

		/**
		* Loops through the file queue and starts the loading process. 
		* 
		* @method _startLoading
		* @private 
		*/
		private _startLoading() {

			//Any files to load?
			if (this._loadingList.length &lt;= 0) {
				Kiwi.Log.log(&#x27;Kiwi.Files.Loader: No files are to load have been found.&#x27;, &#x27;#loading&#x27;);
				this.onQueueProgress.dispatch(100, 0, null);
				this.onQueueComplete.dispatch();
				return;
			}

			//There are files to load
			var i = 0,
				file: Kiwi.Files.File;

			while (i &lt; this._loadingList.length) {

				if (this._calculateBytes) {
					this._loadingList[i].onProgress.add(this._updateFileListInformation, this);
				}

                this._sortFile(this._loadingList[i]);

                this._loadingList[i].onComplete.addOnce(this._fileQueueUpdate, this);

				i++;
			}

			this._queueLoading = true;
			this._bytesLoaded = 0;

			this._startLoadingQueue();
			this._startLoadingAllParallel();

			this._fileQueueUpdate(null, true);

		}

		/**
		* Adds a file to the queue of files to be loaded.
		* Files cannot be added whilst the queue is currently loading, 
		* the file to add is currently loading, or has been loaded before.
		* 
		* @method addFileToQueue
		* @param file {Kiwi.Files.File} The file to add.
		* @return {Boolean} If the file was added to the queue or not. 
		* @since 1.2.0
		* @public
		*/
		public addFileToQueue(file: Kiwi.Files.File) {

			if (this._queueLoading) {
				Kiwi.Log.warn(&#x27;Kiwi.Files.Loader: File cannot be added to the queue whilst the queue is currently loading.&#x27;, &#x27;#loading&#x27;, &#x27;#filequeue&#x27;);
				return false;
			}

			if (file.loading || file.complete) {
				Kiwi.Log.warn(&#x27;Kiwi.Files.Loader: File could not be added as it is currently loading or has already loaded.&#x27;, &#x27;#loading&#x27;, &#x27;#filequeue&#x27;);
				return false;
			}

			this._loadingList.push(file);
			return true;
		}

		/**
		* Removes a file from the file queue. 
		* Files cannot be removed whilst the queue is loading.
		*
		* @method removeFileFromQueue
		* @param file {Kiwi.Files.File} The file to remove.
		* @return {Boolean} If the file was added to the queue or not.
		* @since 1.2.0
		* @public
		*/
		public removeFileFromQueue(file: Kiwi.Files.File): boolean {

			if (this._queueLoading) {
				Kiwi.Log.warn(&#x27;Kiwi.Files.Loader: File cannot be remove from the queue whilst the queue is currently loading.&#x27;, &#x27;#loading&#x27;, &#x27;#filequeue&#x27;);
				return false;
			}

			var index = this._loadingList.indexOf(file);

			if (index === -1) {
				return false;
			} 

			if (file.loading) {
				Kiwi.Log.warn(&#x27;Kiwi.Files.Loader: Cannot remove the file from the list as it is currently loading.&#x27;, &#x27;#loading&#x27;, &#x27;#filequeue&#x27;);
				return false;
			}

			this._loadingList.splice(index, 1);
			return true;
		}

		/**
		* Clears the file queue of all files. 
		* 
		* @method clearQueue
		* @since 1.2.0
		* @public
		*/
		public clearQueue() {

			if (!this._queueLoading) {
				this._loadingList.length = 0;
			} else {
				Kiwi.Log.error(&#x27;Kiwi.Files.Loader: Cannot clear the file queue whilst the files are being loaded.&#x27;, &#x27;#loading&#x27;, &#x27;#filequeue&#x27;);
			}
		}

		/**
		* Starts the process of loading a file outside of the regular queue loading process.
		* Callbacks for load completion need to be added onto the file via &#x27;onComplete&#x27; Signal.
		*
		* @method loadFile
		* @public
		*/
		public loadFile(file: Kiwi.Files.File) {

			if ( file.loading || file.complete ) {
				Kiwi.Log.error(&#x27;Kiwi.Files.Loader: Could not add file. File is already loading or has completed loading.&#x27;);
				return;
			}

			this._sortFile(file, true);

		}

		/**
		* Sorts a file and places it into either the &#x27;loadingParallel&#x27; or &#x27;loadingQueue&#x27; 
		* depending on the method of loading it is using.
		* 
		* @method _sortFile
		* @param file {Kiwi.Files.File}
		* @since 1.2.0
		* @private
		*/
		private _sortFile(file: Kiwi.Files.File, startLoading: boolean = false) {

			if (this.enableParallelLoading &amp;&amp; file.loadInParallel) {
				//Push into the tag loader queue
				this._loadingParallel.push(file);

				if (startLoading) {
					this._startLoadingParallel(file);
				}

			} else {
				//Push into the xhr queue
				this._loadingQueue.push(file);

				if (startLoading) {
					this._startLoadingQueue();
				}
			}

		}

		/**
		* The number of files in the file queue that have been updated.
		* 
		* @property _completeFiles
		* @type number
		* @default 0
		* @private
		*/
		private _completedFiles: number = 0;

		/**
		* Called each time a file has processed whilst loading, or has just completed loading.
		* 
		* Calculates the new number of bytes loaded and 
		* the percentage of loading done by looping through all of the files.
		* 
		* @method _updateFileListInformation
		* @private
		*/
		private _updateFileListInformation() {

			var i = 0;

			this._completedFiles = 0;
			this._bytesLoaded = 0;

			while (i &lt; this._loadingList.length) {

				//Was the file loaded, but we have no bytes (must have used the tag loader) and we have their details?
				if (this._loadingList[i].bytesLoaded === 0 &amp;&amp; this._loadingList[i].success &amp;&amp; this._loadingList[i].detailsReceived) {
					this._bytesLoaded += this._loadingList[i].size;

				} else {
					//Add the bytes loaded to the list 
					this._bytesLoaded += this._loadingList[i].bytesLoaded;
				}

				//Calculate percentage
				if (this._loadingList[i].complete) {
					this._completedFiles++;
				}

				i++;
			}

			//Calculate the percentage depending on how accurate we can be.
			if (this._calculateBytes) {
				this.percentLoaded = (this._bytesLoaded / this._bytesTotal) * 100;
			} else {
				this.percentLoaded = (this._completedFiles / this._loadingList.length) * 100;
			}

		}

		/**
		* Executed by files when they have successfully been loaded.
		* This method checks to see if the files are in the file queue, and dispatches the appropriate events.
		* 
		* @method _fileQueueUpdate
		* @param file {Kiwi.Files.File} The file which has been recently loaded.
		* @param [forceProgressCheck=false] {Boolean} If the progress of file loading should be checked, regardless of the file being in the queue or not.
		* @since 1.2.0
		* @private
		*/
		private _fileQueueUpdate(file: Kiwi.Files.File, forceProgressCheck: boolean = false) {

			//If the file loaded is in the loadingList
			if (!forceProgressCheck &amp;&amp; this._loadingList.indexOf(file) === -1) {
				return;
			}

			//Update the file information.
			this._updateFileListInformation();

			//Dispatch progress event.
			this.onQueueProgress.dispatch(this.percentLoaded, this.bytesLoaded, file);

			if (this._completedFiles &gt;= this._loadingList.length) {
				//Clear the file queue and dispatch the loaded event
				this._queueLoading = false;
				this.clearQueue();
				this.onQueueComplete.dispatch();
			}

		}

		/**
		* Starts the loading process in the loadingQueue. 
		* @method _startLoadingQueue
		* @return {Boolean}
		* @private
		* @since 1.2.0
		* @return {boolean} Whether the first file is loading
		*/
		private _startLoadingQueue(): boolean {

			//Any files to load?
			if (this._loadingQueue.length &lt;= 0) {
				Kiwi.Log.log(&#x27;Kiwi.Files.Loader: No queued files to load.&#x27;, &#x27;#loading&#x27;);
				return false;
			}

			//Is the first file currently loading?
			if (this._loadingQueue[0].loading) {
				return false;
			}

			//Attempt to load the file!
			this._loadingQueue[0].onComplete.addOnce(this._queueFileComplete, this, 1);
			this._loadingQueue[0].load();
			return true;
		}

		/**
		* Executed when a file in the &#x27;loadingQueue&#x27; has been successfully loaded.
		* Removes the file from the loadingQueue and executes the &#x27;_startLoadingQueue&#x27; to start loading the next file. 
		* 
		* @method _queueFileComplete
		* @param file {Kiwi.Files.File}
		* @since 1.2.0
		* @private
		*/
		private _queueFileComplete(file: Kiwi.Files.File) {

			//Remove from the loadingQueue
			var index = this._loadingQueue.indexOf(file);
			if (index === -1) {
				Kiwi.Log.warn(&quot;Something has gone wrong? The file which executed this method doesn&#x27;t exist in the loadingQueue.&quot;, &#x27;#loading&#x27;, &#x27;#error&#x27;);
				return;
			}

			this._loadingQueue.splice(index, 1);

			//Start loading the next file
			this._startLoadingQueue();
		}

		/**
		* Starts loading a file which can be loaded in parallel.
		* @method _startLoadingParallel
		* @param params file {Kiwi.Files.File}
		* @since 1.2.0
		* @private 
		*/
		private _startLoadingParallel( file: Kiwi.Files.File) {

			if (!file.loading) {
                file.onComplete.add(this._parallelFileComplete, this, 1);
				file.load();
			}

		}
		
		/**
		* Starts loading all files which can be loaded in parallel.
		* @method _startLoadingAllParallel
		* @since 1.2.0
		* @private 
		*/
		private _startLoadingAllParallel() {

			var i = 0,
				file: Kiwi.Files.File;

			while (i &lt; this._loadingParallel.length) {
				this._startLoadingParallel(this._loadingParallel[i]);
				i++;
			}

		}
		
		/**
		* Executed when a file in the &#x27;loadingParallel&#x27; lsit has been successfully loaded.
		* Removes the file from the list and get the fileQueue to check its progress.
		* 
		* @method _parallelFileComplete
		* @param file {Kiwi.Files.File}
		* @since 1.2.0
		* @private 
		*/
		private _parallelFileComplete(file: Kiwi.Files.File) {

			var index = this._loadingParallel.indexOf(file);
			if (index === -1) {
				Kiwi.Log.warn(&quot;Something has gone wrong? The file which executed this method doesn&#x27;t exist in the loadingParallel.&quot;, &#x27;#loading&#x27;, &#x27;#error&#x27;);
				return;
            }

			this._loadingParallel.splice(index, 1);
		}


		/**
		* -----------------------------
		* Bytes Loaded Methods 
		* -----------------------------
		**/
		
		/**
		* If the number of bytes for each file should be calculated before the queue starts loading.
		* If true each file in the queue makes a XHR HEAD request first to get the total values.
		*
		* @property _calculateBytes
		* @type Boolean
		* @private 
		*/
		private _calculateBytes: boolean = false;

		/**
		* Callback for when the total number of bytes of the files in the file list has been calculated.
		* 
		* @property onQueueSizeCalculate
		* @type any
		* @private
		*/
		private onSizeCallback: any;
		
		/**
		* Context that the onSizeCallback should be executed in.
		* 
		* @property onSizeContext
		* @type any
		* @private
		*/
		private onSizeContext: any;

		/**
		* The index of the current file in the filelist thats size is being retrieved.
		* @property _currentFileIndex
		* @type number
		* @private
		*/
		private _currentFileIndex: number = 0;

		/**
		* Total file size (in bytes) of all files in the queue to be loaded. 
		* 
		* @property _bytesTotal
		* @type Number
		* @private
		*/
		private _bytesTotal: number = 0;

		/**
		* READ ONLY: Returns the total number of bytes for the files in the file queue.
		* Only contains a value if you use the &#x27;calculateBytes&#x27; and are loading files
		* OR if you use the &#x27;calculateQueuedSize&#x27; method.
		* 
		* @property bytesTotal
		* @readOnly
		* @default 0
		* @since 1.2.0
		* @type Number
		* @public
		*/
		public get bytesTotal(): number {
			return this._bytesTotal;
		}

		/**
		* The number of bytes loaded of files in the file queue. 
		* 
		* @property _bytesLoaded
		* @type Number
		* @private 
		*/
		private _bytesLoaded: number = 0;

		/**
		* READ ONLY: Returns the total number of bytes for the files in the file queue.
		*
		* If you are using this make sure you set the &#x27;calculateBytes&#x27; property to true OR execute the &#x27;calculateQueuedSize&#x27; method. 
		* Otherwise files that are loaded via tags will not be accurate!
		* 
		* @property bytesLoaded
		* @readOnly
		* @default 0
		* @since 1.2.0
		* @type Number
		* @public
		*/
		public get bytesLoaded(): number {
			return this._bytesLoaded;
		}

		/**
		* Loops through the file queue and gets file information (filesize, ETag, filetype) for each.
		* 
		* To get accurate information about the bytesLoaded, bytesTotal, and the percentLoaded 
		* set the &#x27;calculateBytes&#x27; property to true, as the loader will automatically execute this method before hand.
		* 
		* Can only be executed when the file queue is not currently loading.
		* 
		* @method calculateQueuedSize
		* @param callback {any}
		* @param [context=null] {any}
		* @public
		*/
		public calculateQueuedSize(callback: any, context: any = null) {

			//Is the queue currently loading files?
			if (this._queueLoading) {
				Kiwi.Log.warn(&#x27;Kiwi.Files.Loader: Cannot calculate the size of the files in the filequeue whilst they are loading. &#x27;);
				return;
			}

			//Set the callbacks
			this.onSizeCallback = callback;
			this.onSizeContext = context;

			// Start the process
			this._currentFileIndex = 0;
			this._bytesTotal = 0;
			this._queueLoading = true;

			this._calculateNextFileSize();
		}

		/**
		* Checks to see if all the file sizes have been retrieved. 
		* If so completes the &quot;calculateQueuedSize&quot; call.
		* Otherwise requests the next file&#x27;s details.
		*
		* @method _calculateNextFileSize
		* @private
		*/
		private _calculateNextFileSize() {

			if (this._currentFileIndex &gt;= this._loadingList.length) {
				this._queueLoading = false;
				this.onSizeCallback.call(this.onSizeContext, this._bytesTotal);;
				return;
			}
			
			var file = this._loadingList[this._currentFileIndex];

			//Have we already got the details for this file?
			if (file.detailsReceived) {
				this._detailsReceived();
			} else {
				var details = file.loadDetails(this._detailsReceived, this);

				//Skip to the next file if the request could not be made.
				//Shouldn&#x27;t happen.
				if (!details) {
					this._detailsReceived();
				}
			}

		}

		/**
		* Executed when by &#x27;_calculateNextFileSize&#x27; when the files information has been retrieved.
		* Adds its calculated size to the _bytesTotal and executes the &#x27;nextFileSize&#x27; method.
		* 
		* @method _detailsReceived
		* @private 
		*/
		private _detailsReceived() {

			var file = this._loadingList[this._currentFileIndex];

			if (file.detailsReceived) {
				this._bytesTotal += file.size;
			}

			this._currentFileIndex++;
			this._calculateNextFileSize();

		}


		/**
		* -----------------------------
		* File Addition Methods
		* -----------------------------
		*/


		/**
		* Creates a new file for an image and adds a the file to loading queue. 
		* @method addImage
		* @param key {String} The key for the file.
		* @param url {String} The url of the image to load.
		* @param [width] {number} The width of the cell on the image to use once the image is loaded.
		* @param [height] {number} The height of the cell on the image to use once the image is loaded.
		* @param [offsetX] {number} An offset on the x axis of the cell.
		* @param [offsetY] {number} An offset of the y axis of the cell.
		* @param [storeAsGlobal=true] {boolean} If the image should be stored globally or not.
		* @return {Kiwi.Files.File} The file which was created.
		* @public
		*/
		public addImage(key: string, url: string, width?: number, height?: number, offsetX?: number, offsetY?: number, storeAsGlobal: boolean = true): Kiwi.Files.File {

			var params:any = {
				type: Kiwi.Files.File.IMAGE,
				key: null,
				url: null,
				fileStore: this.game.fileStore,
				metadata: {}
			};

			if ( Kiwi.Utils.Common.isObject(key) ) {
				var p: any = key;

				params.key = p.key;
				params.url = p.url;
				params.metadata = {
					width: p.width,
					height: p.height,
					offsetX: p.offsetX,
					offsetY: p.offsetY
				};

				if (p.xhrLoading) params.xhrLoading = p.xhrLoading;//forces blob loading
				if (p.state) params.state = p.state;
				if (p.tags) params.tags = p.tags;

			} else {

				if (!storeAsGlobal &amp;&amp; this.game.states.current) {
					params.state = this.game.states.current;
				}

				params.key = key;
				params.url = url;
				params.metadata = {
					width: width,
					height: height,
					offsetX: offsetX,
					offsetY: offsetY
				};

			}

			var file: Kiwi.Files.File = new Kiwi.Files.TextureFile(this.game, params);
			this.addFileToQueue(file);

			return file;
		}

		/**
		* Creates a new file for a spritesheet and adds the file to the loading queue.
		* @method addSpriteSheet
		* @param key {String} The key for the file.
		* @param url {String} The url of the image to load.
		* @param frameWidth {number} The width of a single cell in the spritesheet.
		* @param frameHeight {number} The height of a single cell in the spritesheet.
		* @param [numCells] {number} The number of cells that are in this spritesheet.
		* @param [rows] {number} The number of cells that are in a row.
		* @param [cols] {number} The number of cells that are in a column.
		* @param [sheetOffsetX] {number} The offset of the whole spritesheet on the x axis.
		* @param [sheetOffsetY] {number} The offset of the whole spritesheet on the y axis.
		* @param [cellOffsetX] {number} The spacing between each cell on the x axis.
		* @param [cellOffsetY] {number} The spacing between each cell on the y axis.
		* @param [storeAsGlobal=true] {boolean} 
		* @return {Kiwi.Files.File} The file which was created.
		* @public
		*/
		public addSpriteSheet(key: string, url: string, frameWidth: number, frameHeight: number, numCells?: number, rows?: number, cols?: number, sheetOffsetX?: number, sheetOffsetY?: number, cellOffsetX?: number, cellOffsetY?: number, storeAsGlobal: boolean = true) {

			var params: any = {
				type: Kiwi.Files.File.SPRITE_SHEET,
				key: null,
				url: null,
				fileStore: this.game.fileStore,
				metadata: {}
			};


			if (Kiwi.Utils.Common.isObject(key)) {
				var p: any = key;

				params.key = p.key;
				params.url = p.url;
				params.metadata = {
					frameWidth: p.frameWidth,
					frameHeight: p.frameHeight,
					numCells: p.numCells,
					rows: p.rows,
					cols: p.cols,
					sheetOffsetX: p.sheetOffsetX,
					sheetOffsetY: p.sheetOffsetY,
					cellOffsetX: p.cellOffsetX,
					cellOffsetY: p.cellOffsetY
				};

				if (p.xhrLoading) params.xhrLoading = p.xhrLoading;//forces blob loading
				if (p.state) params.state = p.state;
				if (p.tags) params.tags = p.tags;

			} else {

				if (!storeAsGlobal &amp;&amp; this.game.states.current) {
					params.state = this.game.states.current;
				}

				params.key = key;
				params.url = url;
				params.metadata = {
					frameWidth: frameWidth,
					frameHeight: frameHeight,
					numCells: numCells,
					rows: rows,
					cols: cols,
					sheetOffsetX: sheetOffsetX,
					sheetOffsetY: sheetOffsetY,
					cellOffsetX: cellOffsetX,
					cellOffsetY: cellOffsetY
				};

			}


			var file = new Kiwi.Files.TextureFile(this.game, params);
			this.addFileToQueue(file);

			return file;
		}

		/**
		* Creates new file&#x27;s for loading a texture atlas and adds those files to the loading queue.
		* @method addTextureAtlas
		* @param key {String} The key for the image file.
		* @param imageUrl {String} The url of the image to load.
		* @param jsonID {String} A key for the JSON file.
		* @param jsonURL {String} The url of the json file to load.
		* @param [storeAsGlobal=true] {Boolean} If hte files should be stored globally or not.
		* @return {Kiwi.Files.File} The file which was created.
		* @public
		*/
		public addTextureAtlas(key: string, imageURL: string, jsonID: string, jsonURL: string, storeAsGlobal: boolean = true) {

			var textureParams: any = {
				type: Kiwi.Files.File.TEXTURE_ATLAS,
				key: key,
				url: imageURL,
				fileStore: this.game.fileStore,
				metadata: {
					jsonID: jsonID
				}
			};
			var jsonParams: any = {
				type: Kiwi.Files.File.JSON,
				key: jsonID,
				url: jsonURL,
				fileStore: this.game.fileStore,
				metadata: {
					imageID: key
				}
			};

			if (!storeAsGlobal &amp;&amp; this.game.states.current) {
				textureParams.state = this.game.states.current;
				jsonParams.state = this.game.states.current;
			}

			if (Kiwi.Utils.Common.isObject(key)) {
				var p: any = key;

				textureParams.key = p.textureAtlasKey;
				textureParams.url = p.textureAtlasURL;
				jsonParams.key = p.jsonKey;
				jsonParams.url = p.jsonURL;

				textureParams.metadata.jsonID = jsonParams.key;
				jsonParams.metadata.imageID = textureParams.key;

				if (p.state) {
					textureParams.state = p.state;
					jsonParams.state = p.state;
				}

				if (p.xhrLoading) textureParams.xhrLoading = p.xhrLoading; //forces blob loading
				if (p.tags) {
					jsonParams.tags = p.tags;
					textureParams.tags = p.tags;
				}

			}

			var imageFile = new Kiwi.Files.TextureFile(this.game, textureParams);
			var jsonFile = new Kiwi.Files.DataFile(this.game, jsonParams);

			this.addFileToQueue(imageFile);
			this.addFileToQueue(jsonFile);

			return imageFile;
		}

		/**
		* Creates a new File to store a audio piece. 
		* This method firstly checks to see if the AUDIO file being loaded is supported or not by the browser/device before adding it to the loading queue.
		* You can override this behaviour and tell the audio data to load even if not supported by setting the &#x27;onlyIfSupported&#x27; boolean to false.
		* Also you can now pass an array of filepaths, and the first audio filetype that is supported will be loaded.
		*
		* @method addAudio
		* @param key {String} The key for the audio file.
		* @param url {String} The url of the audio to load. You can pass an array of URLs, in which case the first supported audio filetype in the array will be loaded.
		* @param [storeAsGlobal=true] {Boolean} If the file should be stored globally.
		* @param [onlyIfSupported=true] {Boolean} If the audio file should only be loaded if Kiwi detects that the audio file could be played. 
		* @return {Kiwi.Files.File} The file which was created.
		* @public
		*/
		public addAudio(key: string, url: any, storeAsGlobal: boolean = true, onlyIfSupported: boolean = true) {

			var params = {
				type: Kiwi.Files.File.AUDIO,
				key: null,
				url: null,
				state: null,
				fileStore: this.game.fileStore
			};

			if (Kiwi.Utils.Common.isObject(key)) {
				params = (&lt;any&gt;key);
				params.fileStore = this.game.fileStore;

			} else {
				params.key = key;
				params.url = url;

				if (!storeAsGlobal &amp;&amp; this.game.states.current) {
					params.state = this.game.states.current;
				}

			}

			var i = 0,
				urls, file;

			//If it is a string then try to load that file
			if (Kiwi.Utils.Common.isString(params.url)) {
				urls = [params.url];
			} else {
				urls = params.url;
			}

			while (i &lt; urls.length) {

				params.url = urls[i]
				file = this._attemptToAddAudio(params, onlyIfSupported);
				if (file) {
					return file;
				}

				i++;
			}

			return null;
		}

		/**
		* This method firstly checks to see if the AUDIO file being loaded is supported or not by the browser/device before adding it to the loading queue.
		* Returns a boolean if the audio file was successfully added or not to the file directory.
		* @method _attemptToAddAudio
		* @param params {Object} 
		*   @param params.key {String} The key for the audio file.
		*   @param params.url {String} The url of the audio to load. 
		*   @param [params.state=true] {Kiwi.State} The state this file should be for.
		*   @param [params.fileStore] {Kiwi.Files.FileStore} 
		* @param [onlyIfSupported=true] {Boolean} If the audio file should only be loaded if Kiwi detects that the audio file could be played. 
		* @return {Kiwi.Files.File} The file which was created.
		* @private
		*/
		private _attemptToAddAudio(params:any, onlyIfSupported: boolean): Kiwi.Files.File {

			var file = new Kiwi.Files.AudioFile(this.game, params);
			var support = false;

			switch (file.extension) {
				case &#x27;mp3&#x27;:
					support = Kiwi.DEVICE.mp3;
					break;

				case &#x27;ogg&#x27;:
				case &#x27;oga&#x27;:
					support = Kiwi.DEVICE.ogg;
					break;

				case &#x27;m4a&#x27;:
					support = Kiwi.DEVICE.m4a;
					break;

				case &#x27;wav&#x27;:
				case &#x27;wave&#x27;:
					support = Kiwi.DEVICE.wav;
					break;
			}

			if (support == true || onlyIfSupported == false) {
				this.addFileToQueue(file);
				return file;
			} else {
				Kiwi.Log.error(&#x27;Kiwi.Loader: Audio Format not supported on this Device/Browser.&#x27;, &#x27;#audio&#x27;, &#x27;#unsupported&#x27;);
				return null;
			}

		}

		/**
		* Creates a new File to store JSON and adds it to the loading queue.
		* @method addJSON
		* @param key {String} The key for the file.
		* @param url {String} The url to the json file.
		* @param [storeAsGlobal=true] {Boolean} If the file should be stored globally.
		* @return {Kiwi.Files.File} The file which was created.
		* @public
		*/
		public addJSON(key: string, url: string, storeAsGlobal: boolean = true) {

			var params: any = {
				type: Kiwi.Files.File.JSON,
				key: key, 
				url: url,
				fileStore: this.game.fileStore
			};

			if (Kiwi.Utils.Common.isObject(key)) {
				var p: any = key;

				params.key = p.key;
				params.url = p.url;

				if (p.parse) params.parse = p.parse;
				if (p.state) params.state = p.state;
				if (p.tags) params.tags = p.tags;

			} else {

				if (!storeAsGlobal &amp;&amp; this.game.states.current) {
					params.state = this.game.states.current;
				}

			}

			var file = new Kiwi.Files.DataFile(this.game, params);
			this.addFileToQueue(file);
			return file;

		}

		/**
		* Creates a new File to store XML and adds it to the loading queue.
		* @method addXML
		* @param key {String} The key for the file.
		* @param url {String} The url to the xml file.
		* @param [storeAsGlobal=true] {Boolean} If the file should be stored globally.
		* @return {Kiwi.Files.File} The file which was created.
		* @public
		*/
		public addXML(key: string, url: string, storeAsGlobal: boolean = true) {
			
			var params:any = {
				type: Kiwi.Files.File.XML,
				key: key,
				url: url,
				fileStore: this.game.fileStore
			};

			if (Kiwi.Utils.Common.isObject(key)) {
				var p: any = key;

				params.key = p.key;
				params.url = p.url;

				if (p.parse) params.parse = p.parse;
				if (p.state) params.state = p.state;
				if (p.tags) params.tags = p.tags;

			} else {

				if (!storeAsGlobal &amp;&amp; this.game.states.current) {
					params.state = this.game.states.current;
				}

			}

			var file = new Kiwi.Files.DataFile(this.game, params);
			this.addFileToQueue(file);
			return file;

		}

		/**
		* Creates a new File for a Binary file and adds it to the loading queue.
		* @method addBinaryFile
		* @param key {String} The key for the file.
		* @param url {String} The url to the Binary file.
		* @param [storeAsGlobal=true] {Boolean} If the file should be stored globally.
		* @return {Kiwi.Files.File} The file which was created.
		* @public
		*/
		public addBinaryFile(key: string, url: string, storeAsGlobal: boolean = true) {

			var params: any = {
				type: Kiwi.Files.File.BINARY_DATA,
				key: key,
				url: url,
				fileStore: this.game.fileStore
			};

			if (Kiwi.Utils.Common.isObject(key)) {
				var p: any = key;

				params.key = p.key;
				params.url = p.url;

				if (p.parse) params.parse = p.parse;
				if (p.state) params.state = p.state;
				if (p.tags) params.tags = p.tags;

			} else {

				if (!storeAsGlobal &amp;&amp; this.game.states.current) {
					params.state = this.game.states.current;
				}

			}

			var file = new Kiwi.Files.DataFile(this.game, params);
			this.addFileToQueue(file);
			return file;

		}

		/**
		* Creates a new File to store a text file and adds it to the loading queue.
		* @method addTextFile
		* @param key {String} The key for the file.
		* @param url {String} The url to the text file.
		* @param [storeAsGlobal=true] {Boolean} If the file should be stored globally.
		* @return {Kiwi.Files.File} The file which was created.
		* @public
		*/
		public addTextFile(key: string, url: string, storeAsGlobal: boolean = true) {

			var params: any = {
				type: Kiwi.Files.File.TEXT_DATA,
				key: key,
				url: url,
				fileStore: this.game.fileStore
			};

			if (Kiwi.Utils.Common.isObject(key)) {
				var p: any = key;

				params.key = p.key;
				params.url = p.url;

				if (p.parse) params.parse = p.parse;
				if (p.state) params.state = p.state;
				if (p.tags) params.tags = p.tags;

			} else {

				if (!storeAsGlobal &amp;&amp; this.game.states.current) {
					params.state = this.game.states.current;
				}

			}

			var file = new Kiwi.Files.DataFile(this.game, params);
			this.addFileToQueue(file);
			return file;

		}

		/**
		* Flags this loader for garbage collection. Only use this method if you are SURE you will no longer need it. 
		* Otherwise it is best to leave it alone.
		* 
		* @method destroy
		* @public
		*/
		public destroy() {

			this.onQueueComplete.dispose();
			this.onQueueProgress.dispose();

			delete this.game;

			delete this.onQueueComplete;
			delete this.onQueueProgress;

			var i = 0;
			while (i &lt; this._loadingList.length) {
				this._loadingList[i].destroy();
				i++;
			}
			this._loadingList = [];

			var i = 0;
			while (i &lt; this._loadingQueue.length) {
				this._loadingQueue[i].destroy();
				i++;
			}
			this._loadingQueue = [];

			var i = 0;
			while (i &lt; this._loadingParallel.length) {
				this._loadingParallel[i].destroy();
				i++;
			}
			this._loadingParallel = [];


		}

		
		/**
		* -----------------------
		* Deprecated - Functionality exists. Maps to its equalvent
		* -----------------------
		**/


		/**
		* Initialise the properities that are needed on this loader.
		* Recommended you use the &#x27;onQueueProgress&#x27; / &#x27;onQueueComplete&#x27; signals instead.
		* 
		* @method init
		* @param [progress=null] {Any} Progress callback method.
		* @param [complete=null] {Any} Complete callback method.
		* @param [calculateBytes=false] {boolean} 
		* @deprecated Deprecated as of 1.2.0
		* @public
		*/
		public init(progress: any = null, complete: any = null, calculateBytes: boolean=null) {

			if (calculateBytes !== null) {
				this._calculateBytes = calculateBytes;
			} 

			if (progress !== null) {
				this.onQueueProgress.addOnce( progress );
			}

			if (complete !== null) {
				this.onQueueComplete.addOnce( complete );
			}

		}

		/**
		* Loops through all of the files that need to be loaded and start the load event on them. 
		* @method startLoad
		* @deprecated Use &#x27;start&#x27; instead. Deprecated as of 1.2.0
		* @public
		*/
		public startLoad() {
			this.start();
		}

		/**
		* Returns a percentage of the amount that has been loaded so far.
		* @method getPercentLoaded
		* @return {Number}
		* @deprecated Use &#x27;percentLoaded&#x27; instead. Deprecated as of 1.2.0
		* @public
		*/
		public getPercentLoaded(): number {
			return this.percentLoaded;
		}


		/**
		* Returns a boolean indicating if everything in the loading que has been loaded or not.
		* @method complete
		* @return {boolean}
		* @deprecated Use &#x27;percentLoaded&#x27; instead. Deprecated as of 1.2.0
		* @public
		*/
		public complete(): boolean {
			return ( this.percentLoaded === 100 );
		}

		/**
		* Quick way of getting / setting the private variable &#x27;calculateBytes&#x27;
		* To be made into a public variable once removed.
		* @method calculateBytes
		* @param [value] {boolean}
		* @return {boolean}
		* @public
		*/
		public calculateBytes(value?: boolean): boolean {

			if (typeof value !== &quot;undefined&quot;) {
				this._calculateBytes = value;
			}

			return this._calculateBytes;
		}

		/**
		* Returns the total number of bytes that have been loaded so far from files in the file queue.
		* 
		* @method getBytesLoaded
		* @return {Number}
		* @readOnly
		* @deprecated Use &#x27;bytesLoaded&#x27; instead. Deprecated as of 1.2.0
		* @public
		*/
		public getBytesLoaded(): number {

			return this.bytesLoaded;
		}

	}

}

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
